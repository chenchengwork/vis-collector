/* eslint-disable camelcase */
import {createGLContext} from '@luma.gl/core';
import {
  assembleShaders,
  createShaderHook,
  createModuleInjection,
  picking,
  fp64
} from '@luma.gl/shadertools';
import test from 'tape-catch';

const fixture = {
  gl: createGLContext()
};

const VS_GLSL_300 = `\
#version 300 es

in vec4 positions;

void main(void) {
  gl_Position = positions;
}
`;
const FS_GLSL_300 = `\
#version 300 es

precision highp float;

out vec4 fragmentColor;

void main(void) {
  fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);
}
`;

test('assembleShaders#import', t => {
  t.ok(assembleShaders !== undefined, 'assembleShaders import successful');
  t.end();
});

test('assembleShaders#version_directive', t => {
  const assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    modules: [picking]
  });
  // Verify version directive remains as first line.
  t.equal(
    assembleResult.vs.indexOf('#version 300 es'),
    0,
    'version directive should be first statement'
  );
  t.equal(
    assembleResult.fs.indexOf('#version 300 es'),
    0,
    'version directive should be first statement'
  );
  t.end();
});

test('assembleShaders#getUniforms', t => {
  const testModuleSettings = {pickingActive: true};

  // inject spy into the picking module's getUniforms
  // const module = getShaderModule(picking);
  // const getUniformsSpy = makeSpy(module, 'getUniforms');

  let assembleResult;

  // Without shader modules
  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300
  });
  // Verify getUniforms is function
  t.is(typeof assembleResult.getUniforms, 'function', 'getUniforms should be function');

  // With shader modules
  const testModule = {
    name: 'test-module',
    vs: '',
    fs: '',
    getUniforms: (opts, context) => {
      // Check a uniform generated by its dependency
      t.ok(context.picking_uActive, 'module getUniforms is called with correct context');
      return {};
    },
    dependencies: ['picking']
  };

  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    modules: [picking, testModule, fp64]
  });

  // Verify getUniforms is function
  t.is(typeof assembleResult.getUniforms, 'function', 'getUniforms should be function');

  assembleResult.getUniforms(testModuleSettings);

  // t.ok(module.getUniforms.called, 'module getUniforms is called');

  // TODO: probe.gl spy does not yet support args
  // t.deepEqual(
  //   picking.getUniforms.getCall(0).args[0],
  //   testModuleSettings,
  //   'module getUniforms is called with correct opts');

  // t.ok(testModule.getUniforms.calledAfter(picking.getUniforms),
  //   'module getUniforms is called after its dependencies');

  // TODO: probe.gl spy does not yet support args
  // t.deepEqual(
  //   testModule.getUniforms.getCall(0).args[0],
  //   testModuleSettings,
  //   'module getUniforms is called with correct opts');

  // getUniformsSpy.restore();

  t.end();
});

test('assembleShaders#shaderhooks', t => {
  createShaderHook('vs:LUMAGL_pickColor(inout vec4 color)');
  createShaderHook('fs:LUMAGL_fragmentColor(inout vec4 color)');

  createModuleInjection('picking', {
    hook: 'vs:LUMAGL_pickColor',
    injection: 'picking_setPickingColor(color.rgb);'
  });

  createModuleInjection('picking', {
    hook: 'fs:LUMAGL_fragmentColor',
    injection: 'color = picking_filterColor(color);',
    order: Number.POSITIVE_INFINITY
  });

  createModuleInjection('picking', {
    hook: 'fs:#main-end',
    injection: 'gl_FragColor = picking_filterColor(gl_FragColor);',
    order: Number.POSITIVE_INFINITY
  });

  let assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300
  });
  // Verify version directive remains as first line.
  t.ok(
    assembleResult.vs.indexOf('LUMAGL_pickColor') > -1,
    'hook function injected into vertex shader'
  );
  t.ok(
    assembleResult.fs.indexOf('LUMAGL_fragmentColor') > -1,
    'hook function injected into fragment shader shader'
  );
  t.ok(
    assembleResult.vs.indexOf('picking_setPickingColor(color.rgb)') === -1,
    'injection code not included in vertex shader without module'
  );
  t.ok(
    assembleResult.fs.indexOf('color = picking_filterColor(color)') === -1,
    'injection code not included in fragment shader without module'
  );

  t.ok(
    assembleResult.fs.indexOf('gl_FragColor = picking_filterColor(gl_FragColor)') === -1,
    'regex injection code not included in fragment shader without module'
  );

  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    modules: [picking]
  });
  // Verify version directive remains as first line.
  t.ok(
    assembleResult.vs.indexOf('LUMAGL_pickColor') > -1,
    'hook function injected into vertex shader'
  );
  t.ok(
    assembleResult.fs.indexOf('LUMAGL_fragmentColor') > -1,
    'hook function injected into fragment shader shader'
  );
  t.ok(
    assembleResult.vs.indexOf('picking_setPickingColor(color.rgb)') > -1,
    'injection code included in vertex shader with module'
  );
  t.ok(
    assembleResult.fs.indexOf('color = picking_filterColor(color)') > -1,
    'injection code included in fragment shader with module'
  );
  t.ok(
    assembleResult.fs.indexOf('gl_FragColor = picking_filterColor(gl_FragColor)') > -1,
    'regex injection code included in fragment shader with module'
  );

  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    inject: {
      'vs:LUMAGL_pickColor': 'color *= 0.1;',
      'fs:LUMAGL_fragmentColor': 'color += 0.1;'
    }
  });

  t.ok(
    assembleResult.vs.indexOf('color *= 0.1') > -1,
    'argument injection code included in shader hook'
  );
  t.ok(
    assembleResult.fs.indexOf('color += 0.1') > -1,
    'argument injection code included in shader hook'
  );

  assembleResult = assembleShaders(fixture.gl, {
    vs: VS_GLSL_300,
    fs: FS_GLSL_300,
    inject: {
      'fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);': 'fragmentColor -= 0.1;'
    }
  });

  t.ok(
    assembleResult.fs.indexOf('fragmentColor -= 0.1;') > -1,
    'regex injection code included in shader hook'
  );

  t.end();
});
