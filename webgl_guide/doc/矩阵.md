#### 1. 3D世界中矩阵作用
用矩阵来表示3D变换，但矩阵在表示旋转时可能会导致万向节锁的问题，而使用四元数可以避免万向节锁

#### 2. 矩阵变换
(1).通常我们使用 4 维向量 (x, y, z, w) 表示在3D空间中的一个点，最后一维 w 表示齐次坐标。齐次坐标的含义是两条平行线在投影平面的无穷远处相交于一点，但在 Matrix 中没有表示无穷大，所以增加了齐次坐标这一维;

(2). 用数组表示 Matrix 又分为两种形式：行主序和列主序，它们在本质上是等价的，只不过是一个是右乘（行主序，矩阵放右边）和一个是左乘（列主序，矩阵放左边）

(3). WebGL 使用列主序矩阵，即列矩阵，因此我们总是倒过来算的（左乘矩阵，变换效果是按从右向左的顺序进行）： 投影矩阵 × 视图矩阵 × 模型矩阵 × 3D位置

    投影矩阵: 定义可视化区域，两种方式“透视投影”和“正交投影”;
    视图矩阵: 为了将物体从世界坐标转换到相机视线所在视图空间中来; glMatrix.lookAt();
    模型矩阵: 变换模型, 如: 平移, 旋转, 缩放等;

#### 3. 逆转置矩阵
(1).逆矩阵含义：
    如果M*R 或 R*M的结果都是单位矩阵， 则M和R将互为逆矩阵;

(2).转置的含义：
    将矩阵的行列进行调换


#### 4. 矩阵运算
(1). 矢量和浮点型的运算(支持交换律)

    v3b = v3a + f;
    -----------------------------
    v3b.x = v3a.x + f;
    v3b.y = v3a.y + f;
    v3b.z = v3a.z + f;

(2). 矢量和矢量的运算(支持交换律)

    v3c = v3a + v3b;
    -----------------------------
    v3c.x = v3a.x + v3b.x;
    v3c.y = v3a.y + v3b.y;
    v3c.z = v3a.z + v3b.z;

(3). 矩阵和浮点型的运算

    m3b = m3a * f;
    -----------------------------
    m3b[0].x = v3a[0].x * f;
    m3b[0].y = v3a[0].y * f;
    m3b[0].z = v3a[0].z * f;

    m3b[1].x = v3a[1].x * f;
    m3b[1].y = v3a[1].y * f;
    m3b[1].z = v3a[1].z * f;

    m3b[2].x = v3a[2].x * f;
    m3b[2].y = v3a[2].y * f;
    m3b[2].z = v3a[2].z * f;

(4). 矩阵右乘矢量的运算

    v3b = m3a * v3a;
    -----------------------------
    v3b.x = m3a[0].x * v3a.x + m3a[1].x * v3a.y + m3a[2].x * v3a.z;

    v3b.y = m3a[0].y * v3a.x + m3a[1].y * v3a.y + m3a[2].y * v3a.z;

    v3b.z = m3a[0].z * v3a.x + m3a[1].z * v3a.y + m3a[2].z * v3a.z;

(5). 矩阵左乘矢量的运算

    v3b = v3a * m3a;
    -----------------------------
    v3b.x = v3a.x * m3a[0].x + v3a.y * m3a[0].y + v3a.z * m3a[0].z;

    v3b.y = v3a.x * m3a[1].x + v3a.y * m3a[1].y + v3a.z * m3a[1].z;

    v3b.z = v3a.x * m3a[2].x + v3a.y * m3a[2].y + v3a.z * m3a[2].z;

(6). 矩阵乘以矩阵的运算

    m3c = m3a * m3b;
    左矩阵的行 * 右矩阵的列 然后求和
    -----------------------------
    m3c[0].x = m3a[0].x * m3b[0].x + m3a[1].x * m3b[0].y + m3a[2].x * m3b[0].z;
    m3c[0].y = m3a[0].x * m3b[1].x + m3a[1].x * m3b[1].y + m3a[2].x * m3b[1].z;
    m3c[0].z = m3a[0].x * m3b[2].x + m3a[1].x * m3b[2].y + m3a[2].x * m3b[2].z;

    m3c[1].x = m3a[0].y * m3b[0].x + m3a[1].y * m3b[0].y + m3a[2].y * m3b[0].z;
    m3c[1].y = m3a[0].y * m3b[1].x + m3a[1].y * m3b[1].y + m3a[2].y * m3b[1].z;
    m3c[1].z = m3a[0].y * m3b[2].x + m3a[1].y * m3b[2].y + m3a[2].y * m3b[2].z;

    m3c[2].x = m3a[0].z * m3b[0].x + m3a[1].z * m3b[0].y + m3a[2].z * m3b[0].z;
    m3c[2].y = m3a[0].z * m3b[1].x + m3a[1].z * m3b[1].y + m3a[2].z * m3b[1].z;
    m3c[2].z = m3a[0].z * m3b[2].x + m3a[1].z * m3b[2].y + m3a[2].z * m3b[2].z;







